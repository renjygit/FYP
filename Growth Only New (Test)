import numpy as np
import matplotlib.pyplot as plt
import sys
import csv

# Define the van Leer flux limiter function
def vanLeerFunc(X):
    return (X + np.abs(X)) / (1 + X)

# Define required constants
R = 8.314
kB = 1.38e-23
NA = 6.022e23
A = 4e3
VmMolar = 3.2996e-5 # m^3 mol^-1 - molar volume of monomer
rmMolar = (3/4*np.pi) * pow(VmMolar, 1/3)
Vm = VmMolar / NA # (4/3)*np.pi*pow(rm,3)
rm = pow((3*Vm) / (4*np.pi), (1/3)) # 1.87e-10
D = 1e-12
Vtot = 1e-4 #0.0252-3 # m^3
MInf = 1e-2 #mol m^-3 #
u = 0.42 # coagulation parameter
gamma = 0.2 #0.4 # J m^-2 - surface energy
k = 1e12 # J mol^-1 m^-1 - constant in the exponent of the distribution function
kr = 1.6e-9
density = 5.816e3 # kg m^-3
MW = 0.09586 # kg mol^-1 - monomeric molecular weight
Q = (4*np.pi*density) / (3 * MW * Vtot * MInf)
smallVal = 1e-30

# Define timesteps to iterate through & create an array
tmax = 24e-5 #s
tdiff = 3e-5
tmin = tdiff
timeArray = np.linspace(tdiff, tmax, int((tmax-tmin+tdiff)/tdiff))


# Define radius bins
rdiff =  2e-11 # m
rmax = 8.1e-9
rmin = 1e-10
rBins = np.linspace(rmin,rmax,int((rmax-rmin+rdiff)/rdiff))

# Define temperature variable & heating rate
Temp = 503 # 453
Tf = 567
HR = 0.025 # K s^-1 (1.5 K min^-1)

# Define supersaturation variable & array
SS = 5e2
SSArray = [SS]

# Create an array of arrays to hold number of nuclei in each radius bin for different timesteps
NArraysArray = [[]]

# Give number of nanopartices initially
NNumMole = 60e-6 # mol
NNum = NNumMole * NA # number
print("Initial number of nanoparticles = " + str(NNum))

# Create the input distribution of nanoparticles
sum = 0
for r in rBins:
    g = (1 / (1.5e-10 * np.sqrt((2*np.pi)))) * np.exp(-0.5*(np.power((r - 1e-9)/(1.5e-10), 2))) # Normal distribution with mean radius 1e-9 m & standard deviation 1e-10 m
    gN = NNum * g * rdiff
    
    sum += gN # Calculated to check this sums to NNum (approximately)
    
    NArraysArray[0].append(gN)
print("Sum of nanoparticles in initial distribution = " + str(sum))

NNumArray = [np.sum(NArraysArray[0])]

#print(list(zip(NArraysArray[0], rBins)))

# Plot the initial distribution of nanoparticles
plt.plot(rBins, NArraysArray[0])
plt.title("Nanoparticles number against radius at t = 0")
plt.ylim(0, 4.5e18)
plt.show()

# Create an array to hold the mean radius values
NArrayAvgR = [np.average(rBins, weights = NArraysArray[0])]
print("Initial avg N = " + str(NArrayAvgR[0]))


timeCount = 0 # Used to track number of time iterations
# Main loop steps forward in time
for time in timeArray:
    timeCount += 1

    #print("temp " +str(Temp))
    
    # Calculate the critical radius
    rCrit = (2*gamma*VmMolar) / (R*Temp*np.log(SS))
    #print("rCrit = " + str(rCrit))
    
    # Calculate the de-dimensionalised variables
    phi = (R * Temp) / (2 * gamma *VmMolar)
    psi = phi**2 * D * VmMolar * MInf
    zeta = 1e-3 # (D * phi) / kr
    tau = time * psi

    # Add a new empty array to the N array of arrays to hold the newly calculated N values
    NArraysArray.append([])
    # Create empty arrays for the SS integral elements and the N values at radii values of (i+1/2) and (i-1/2) (reset each time iteration)
    SSSumsArray = []
    NForwardList = []
    NBackwardList = []
    
    i = -1  # Used to count through rBins to find rBins element closest in value to rCrit so that the appopriate NArraysArray value can be chosen to plot the rCrit value
    rCount = -1 # Keep track of the number of radius iterations (resets each time iteration)
    for r in rBins:
        rCount += 1
        
        if rCrit > r:
            i += 1
        
        
        # Find beta values for radii values (i+1/2) and (i-1/2)
        betaCentre = r * phi # centred
        betaPos = (r+0.5*rdiff) * phi # de-dimensionalised radius
        betaNeg = (r-0.5*rdiff) * phi # de-dimensionalised radius

        # Calculate the growth rates using these beta values & then redimensionalise them
        #growthRateCentreDD = (SS - np.exp(1/betaCentre))/(betaCentre + zeta)
        growthRatePosDD = (SS - np.exp(1/betaPos))/(betaPos + zeta) # De-dimensionalised
        growthRateNegDD = (SS - np.exp(1/betaNeg))/(betaNeg + zeta) # De-dimensionalised
        #growthRateCentre = growthRateCentreDD * (psi/phi)
        growthRatePos = growthRatePosDD * (psi/phi) # Re-dimensionalised
        growthRateNeg = growthRateNegDD * (psi/phi) # Re-dimensionalised
        
        
        # Calculate the intermediate value of N, i.e. the nucleated N (for this radius value)
        Nprime = NArraysArray[0][rCount] + 0 # This adds 0 for the growth only case, since there is no nucleation
        
        # Deltapos & deltaneg use number of nanoparticles at radii (i+1) & (i-1), which don't exist at the boundaries, so set NForward and NBackward to previous N for these edge cases
        if r == rBins[0] or r == rBins[1] or r == rBins[len(rBins) - 1] or r == rBins[len(rBins) - 2]:
            NForward = NArraysArray[0][rCount]
            NBackward = NArraysArray[0][rCount]
            NForwardList.append(NForward)
            NBackwardList.append(NBackward)
        else:
            # Calculate deltapos and deltaneg
            deltapos = NArraysArray[0][rCount+1] - NArraysArray[0][rCount]
            deltaForward = NArraysArray[0][rCount+2] - NArraysArray[0][rCount+1] # calculate delta+ for the next rbin
            deltaneg = NArraysArray[0][rCount] - NArraysArray[0][rCount-1]
            deltaBackward = NArraysArray[0][rCount-1] - NArraysArray[0][rCount-2] # calculate delta- for the previous rbin 
            
            # If one or both of the deltas = 0, one or both of their ratios will diverge / be undefined, so include a condition to avoid this
            if abs(deltapos) <= smallVal:
                # Add a small constant to deltapos and deltaneg to avoid division by 0
                if r >= NArrayAvgR[timeCount-1]:
                    deltapos = -smallVal
                else:
                    deltapos = smallVal

            if abs(deltaneg) <= smallVal:
                if r >= NArrayAvgR[timeCount-1]:
                    deltaneg = -smallVal
                else:
                    deltaneg = smallVal
                    
            if abs(deltaForward) <= smallVal:
                if (r+rdiff) >= NArrayAvgR[timeCount-1]:
                    deltaForward = -smallVal
                else:
                    deltaForward = smallVal

            if abs(deltaBackward) <= smallVal:
                if (r-rdiff) >= NArrayAvgR[timeCount-1]:
                    deltaBackward = -smallVal
                else:
                    deltaBackward = smallVal
            
            
            # Calculate NForward and NBackward using the van Leer function
            # Calculate the value of N at the right interface, using the formula for Ni+1/2 centred on Ni if the growth rate there is > 0 or the formula for Ni-1/2 centred on Ni+1 if not
            if growthRatePos > 0:
                NForward = NArraysArray[0][rCount] + 0.5*vanLeerFunc(deltapos/deltaneg)*deltaneg
            else:
                NForward = NArraysArray[0][rCount+1] - 0.5*vanLeerFunc(deltapos/deltaForward)*deltaForward # find n-1/2 for next radius bin
            #print("NForward = " + str(NForward))1
            NForwardList.append(NForward)
            
            # Calculate the value of N at the left interface, using the formula for Ni-1/2 centred on Ni if the growth rate there is < 0 or the formula for Ni+1/2 centred on Ni-1 if not
            if growthRateNeg < 0:
                NBackward = NArraysArray[0][rCount] - 0.5*vanLeerFunc(deltaneg/deltapos)*deltapos
            else:
                NBackward = NArraysArray[0][rCount-1] + 0.5*vanLeerFunc(deltaneg/deltaBackward)*deltaBackward # find n+1/2 for previous radius bin
            #print("NBackward = " + str(NForward))
            NBackwardList.append(NBackward)
            
            # debugging
            if rCount == 10: # values for element 10 of r bins
                print("NForward = " + str(NForward))
                print("NBackward = " + str(NBackward))

        # Check Courant condition & stop the program if not satisfied
        if (growthRatePos * tdiff/rdiff) > 1 or (growthRateNeg * tdiff/rdiff) >1: # don't check -ve growth values as these are corrected by setting values of n less than 0 to 0
            print("Courant condition not satisfied.")
            print("Courant value for growthratepos " + str(np.abs(growthRatePos) * tdiff/rdiff))
            print("Courant value for growthrateneg " + str(np.abs(growthRateNeg) * tdiff/rdiff))
            sys.exit()    
        
        
        # Calculate new N & add to the array
        NNew = Nprime - (tdiff/rdiff) * ((growthRatePos*NForward) - (growthRateNeg*NBackward)) # Calculate new N, i.e. N for current timestep
        
        """
        if growthRateCentre > 0:
            NNew = Nprime - (tdiff/rdiff) * ((growthRatePos*NForward) - (growthRateNeg*NBackward)) # Calculate new N, i.e. N for current timestep
        else:
            NNew = Nprime - (tdiff/rdiff) * ((growthRatePos*NBackward) - (growthRateNeg*NBackward)) # Calculate new N, i.e. N for current timestep
        """
        
        # Do not allow the non-physical case of negative amounts of nuclei
        if NNew < 0:
            NNew = 1e-50 # maybe set to 0
        
        
        NArraysArray[1].append(NNew)

        # Calculate element of SS integral for current r & add to array
        SSIntegralElement = pow(r,3) * (NArraysArray[1][rCount] - NArraysArray[0][rCount])
        SSSumsArray.append(SSIntegralElement)
        #print("Q * r^3 = " + str(Q*pow(r,3)))
        #print("SS Element = " + str(SSIntegralElement))
        
        """
        if timeCount % 1000 == 0:         
            if rCount == 100:
                print("delta pos = " + str(deltapos))
                print("delta neg = " + str(deltaneg))
                print("Nprime = " + str(Nprime))
                print("NNew = " + str(NNew))
                print("growthRatePos = " + str(growthRatePos))
                print("growthRateNeg = " + str(growthRateNeg))
        """
    
    # Add mean radius of N to the array
    NArrayAvgR.append(np.average(rBins, weights = NArraysArray[1]))
    #print("Avg N radius = " + str(NArrayAvgR[timeCount]))
    # Delete N array for previous timestep (to conserve memory, since it is no longer needed)
    del NArraysArray[0]
    print(NArraysArray[0])

        
    # Calculate SS value for this timestep & add to the array
    SS -= (Q * np.sum(SSSumsArray)) # Sum all integral element values and multiply by Q to approximate the integral (no precursor part to consider for growth only case)
    SSArray.append(SS)
    #print("SS " + str(SS))
    #print("   ")
    
    NNumArray.append(np.sum(NArraysArray[0]))
    
    if timeCount % 1 == 0:
        plt.plot(rBins, NArraysArray[0])
        plt.title("Nanoparticles number against radius at t = " + f'{time:.3g}')
        #plt.ylim(0, 4.5e18)
        plt.xlim(0,8e-9)
        plt.plot(rCrit, NArraysArray[0][i], 'ko')
        print("N at r Crit = " + str(NArraysArray[0][i]))
        plt.show()
        #print(NArraysArray[0])
    
    """
    # Increase the temperature by the heating rate up to the maximum
    if (Temp < Tf):
        Temp += tdiff*HR
    """
    
# Create new time array to include t = 0
timeArrayFull = np.linspace(0, tmax, int(((tmax-tmin+tdiff)/tdiff) + 1))

# Plot the final distribution of nanoparticles
plt.plot(rBins, NArraysArray[0])
plt.title("Final nanoparticle size distribution gamma = " + str(gamma))
#plt.ylim(0, 4.)
plt.plot(rCrit, NArraysArray[0][i], 'ko')
plt.show()


#print(NArrayAvgR)
# Plot mean radius against time
plt.plot(timeArrayFull, NArrayAvgR)
plt.title("Mean radius against time gamma = " + str(gamma))
plt.xscale('log')
plt.show()


# Plot supersaturation against time
plt.plot(timeArrayFull, SSArray)
plt.title("Supersaturation against time gamma = " + str(gamma))
plt.xscale('log')
plt.yscale('log')
plt.show()


# Plot the total number of nanoparticles over time
plt.plot(timeArrayFull, NNumArray)
plt.title("Number of nanoparticles over time gamma = " + str(gamma))
plt.xscale('log')
plt.show()
